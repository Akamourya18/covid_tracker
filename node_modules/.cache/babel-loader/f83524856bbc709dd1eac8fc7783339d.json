{"ast":null,"code":"/*!\r\n  * Bootstrap carousel.js v5.0.1 (https://getbootstrap.com/)\r\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/selector-engine.js'), require('./dom/data.js'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/selector-engine', './dom/data', './dom/event-handler', './dom/manipulator', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Carousel = factory(global.SelectorEngine, global.Data, global.EventHandler, global.Manipulator, global.Base));\n})(this, function (SelectorEngine, Data, EventHandler, Manipulator, BaseComponent) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n\n  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);\n\n  var Data__default = /*#__PURE__*/_interopDefaultLegacy(Data);\n\n  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);\n\n  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);\n\n  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);\n\n  const TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  const toType = obj => {\n    if (obj === null || obj === undefined) {\n      return `${obj}`;\n    }\n\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n\n  const getSelector = element => {\n    let selector = element.getAttribute('data-bs-target');\n\n    if (!selector || selector === '#') {\n      let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n\n      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\n        hrefAttr = `#${hrefAttr.split('#')[1]}`;\n      }\n\n      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;\n    }\n\n    return selector;\n  };\n\n  const getElementFromSelector = element => {\n    const selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n\n  const triggerTransitionEnd = element => {\n    element.dispatchEvent(new Event(TRANSITION_END));\n  };\n\n  const isElement = obj => {\n    if (!obj || typeof obj !== 'object') {\n      return false;\n    }\n\n    if (typeof obj.jquery !== 'undefined') {\n      obj = obj[0];\n    }\n\n    return typeof obj.nodeType !== 'undefined';\n  };\n\n  const typeCheckConfig = (componentName, config, configTypes) => {\n    Object.keys(configTypes).forEach(property => {\n      const expectedTypes = configTypes[property];\n      const value = config[property];\n      const valueType = value && isElement(value) ? 'element' : toType(value);\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(`${componentName.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n      }\n    });\n  };\n\n  const isVisible = element => {\n    if (!element) {\n      return false;\n    }\n\n    if (element.style && element.parentNode && element.parentNode.style) {\n      const elementStyle = getComputedStyle(element);\n      const parentNodeStyle = getComputedStyle(element.parentNode);\n      return elementStyle.display !== 'none' && parentNodeStyle.display !== 'none' && elementStyle.visibility !== 'hidden';\n    }\n\n    return false;\n  };\n\n  const reflow = element => element.offsetHeight;\n\n  const getjQuery = () => {\n    const {\n      jQuery\n    } = window;\n\n    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return jQuery;\n    }\n\n    return null;\n  };\n\n  const onDOMContentLoaded = callback => {\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', callback);\n    } else {\n      callback();\n    }\n  };\n\n  const isRTL = () => document.documentElement.dir === 'rtl';\n\n  const defineJQueryPlugin = plugin => {\n    onDOMContentLoaded(() => {\n      const $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        const name = plugin.NAME;\n        const JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n\n        $.fn[name].noConflict = () => {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.0.1): carousel.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n\n  /**\r\n   * ------------------------------------------------------------------------\r\n   * Constants\r\n   * ------------------------------------------------------------------------\r\n   */\n\n\n  const NAME = 'carousel';\n  const DATA_KEY = 'bs.carousel';\n  const EVENT_KEY = `.${DATA_KEY}`;\n  const DATA_API_KEY = '.data-api';\n  const ARROW_LEFT_KEY = 'ArrowLeft';\n  const ARROW_RIGHT_KEY = 'ArrowRight';\n  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  const SWIPE_THRESHOLD = 40;\n  const Default = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true,\n    touch: true\n  };\n  const DefaultType = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean',\n    touch: 'boolean'\n  };\n  const ORDER_NEXT = 'next';\n  const ORDER_PREV = 'prev';\n  const DIRECTION_LEFT = 'left';\n  const DIRECTION_RIGHT = 'right';\n  const EVENT_SLIDE = `slide${EVENT_KEY}`;\n  const EVENT_SLID = `slid${EVENT_KEY}`;\n  const EVENT_KEYDOWN = `keydown${EVENT_KEY}`;\n  const EVENT_MOUSEENTER = `mouseenter${EVENT_KEY}`;\n  const EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY}`;\n  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY}`;\n  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY}`;\n  const EVENT_TOUCHEND = `touchend${EVENT_KEY}`;\n  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY}`;\n  const EVENT_POINTERUP = `pointerup${EVENT_KEY}`;\n  const EVENT_DRAG_START = `dragstart${EVENT_KEY}`;\n  const EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`;\n  const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;\n  const CLASS_NAME_CAROUSEL = 'carousel';\n  const CLASS_NAME_ACTIVE = 'active';\n  const CLASS_NAME_SLIDE = 'slide';\n  const CLASS_NAME_END = 'carousel-item-end';\n  const CLASS_NAME_START = 'carousel-item-start';\n  const CLASS_NAME_NEXT = 'carousel-item-next';\n  const CLASS_NAME_PREV = 'carousel-item-prev';\n  const CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  const SELECTOR_ACTIVE = '.active';\n  const SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\n  const SELECTOR_ITEM = '.carousel-item';\n  const SELECTOR_ITEM_IMG = '.carousel-item img';\n  const SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\n  const SELECTOR_INDICATORS = '.carousel-indicators';\n  const SELECTOR_INDICATOR = '[data-bs-target]';\n  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\n  const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n  const POINTER_TYPE_TOUCH = 'touch';\n  const POINTER_TYPE_PEN = 'pen';\n  /**\r\n   * ------------------------------------------------------------------------\r\n   * Class Definition\r\n   * ------------------------------------------------------------------------\r\n   */\n\n  class Carousel extends BaseComponent__default['default'] {\n    constructor(element, config) {\n      super(element);\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this.touchStartX = 0;\n      this.touchDeltaX = 0;\n      this._config = this._getConfig(config);\n      this._indicatorsElement = SelectorEngine__default['default'].findOne(SELECTOR_INDICATORS, this._element);\n      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      this._pointerEvent = Boolean(window.PointerEvent);\n\n      this._addEventListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default;\n    }\n\n    static get NAME() {\n      return NAME;\n    } // Public\n\n\n    next() {\n      if (!this._isSliding) {\n        this._slide(ORDER_NEXT);\n      }\n    }\n\n    nextWhenVisible() {\n      // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n      if (!document.hidden && isVisible(this._element)) {\n        this.next();\n      }\n    }\n\n    prev() {\n      if (!this._isSliding) {\n        this._slide(ORDER_PREV);\n      }\n    }\n\n    pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n\n      if (SelectorEngine__default['default'].findOne(SELECTOR_NEXT_PREV, this._element)) {\n        triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n\n    cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n\n      if (this._config && this._config.interval && !this._isPaused) {\n        this._updateInterval();\n\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    }\n\n    to(index) {\n      this._activeElement = SelectorEngine__default['default'].findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n      const activeIndex = this._getItemIndex(this._activeElement);\n\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        EventHandler__default['default'].one(this._element, EVENT_SLID, () => this.to(index));\n        return;\n      }\n\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n\n      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n\n      this._slide(order, this._items[index]);\n    } // Private\n\n\n    _getConfig(config) {\n      config = { ...Default,\n        ...config\n      };\n      typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    }\n\n    _handleSwipe() {\n      const absDeltax = Math.abs(this.touchDeltaX);\n\n      if (absDeltax <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      const direction = absDeltax / this.touchDeltaX;\n      this.touchDeltaX = 0;\n\n      if (!direction) {\n        return;\n      }\n\n      this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\n    }\n\n    _addEventListeners() {\n      if (this._config.keyboard) {\n        EventHandler__default['default'].on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n      }\n\n      if (this._config.pause === 'hover') {\n        EventHandler__default['default'].on(this._element, EVENT_MOUSEENTER, event => this.pause(event));\n        EventHandler__default['default'].on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));\n      }\n\n      if (this._config.touch && this._touchSupported) {\n        this._addTouchEventListeners();\n      }\n    }\n\n    _addTouchEventListeners() {\n      const start = event => {\n        if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n          this.touchStartX = event.clientX;\n        } else if (!this._pointerEvent) {\n          this.touchStartX = event.touches[0].clientX;\n        }\n      };\n\n      const move = event => {\n        // ensure swiping with one touch and not pinching\n        this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;\n      };\n\n      const end = event => {\n        if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n          this.touchDeltaX = event.clientX - this.touchStartX;\n        }\n\n        this._handleSwipe();\n\n        if (this._config.pause === 'hover') {\n          // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          this.pause();\n\n          if (this.touchTimeout) {\n            clearTimeout(this.touchTimeout);\n          }\n\n          this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n        }\n      };\n\n      SelectorEngine__default['default'].find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\n        EventHandler__default['default'].on(itemImg, EVENT_DRAG_START, e => e.preventDefault());\n      });\n\n      if (this._pointerEvent) {\n        EventHandler__default['default'].on(this._element, EVENT_POINTERDOWN, event => start(event));\n        EventHandler__default['default'].on(this._element, EVENT_POINTERUP, event => end(event));\n\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        EventHandler__default['default'].on(this._element, EVENT_TOUCHSTART, event => start(event));\n        EventHandler__default['default'].on(this._element, EVENT_TOUCHMOVE, event => move(event));\n        EventHandler__default['default'].on(this._element, EVENT_TOUCHEND, event => end(event));\n      }\n    }\n\n    _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      if (event.key === ARROW_LEFT_KEY) {\n        event.preventDefault();\n\n        this._slide(DIRECTION_RIGHT);\n      } else if (event.key === ARROW_RIGHT_KEY) {\n        event.preventDefault();\n\n        this._slide(DIRECTION_LEFT);\n      }\n    }\n\n    _getItemIndex(element) {\n      this._items = element && element.parentNode ? SelectorEngine__default['default'].find(SELECTOR_ITEM, element.parentNode) : [];\n      return this._items.indexOf(element);\n    }\n\n    _getItemByOrder(order, activeElement) {\n      const isNext = order === ORDER_NEXT;\n      const isPrev = order === ORDER_PREV;\n\n      const activeIndex = this._getItemIndex(activeElement);\n\n      const lastItemIndex = this._items.length - 1;\n      const isGoingToWrap = isPrev && activeIndex === 0 || isNext && activeIndex === lastItemIndex;\n\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n\n      const delta = isPrev ? -1 : 1;\n      const itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    }\n\n    _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      const targetIndex = this._getItemIndex(relatedTarget);\n\n      const fromIndex = this._getItemIndex(SelectorEngine__default['default'].findOne(SELECTOR_ACTIVE_ITEM, this._element));\n\n      return EventHandler__default['default'].trigger(this._element, EVENT_SLIDE, {\n        relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n    }\n\n    _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        const activeIndicator = SelectorEngine__default['default'].findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n        activeIndicator.classList.remove(CLASS_NAME_ACTIVE);\n        activeIndicator.removeAttribute('aria-current');\n        const indicators = SelectorEngine__default['default'].find(SELECTOR_INDICATOR, this._indicatorsElement);\n\n        for (let i = 0; i < indicators.length; i++) {\n          if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n            indicators[i].classList.add(CLASS_NAME_ACTIVE);\n            indicators[i].setAttribute('aria-current', 'true');\n            break;\n          }\n        }\n      }\n    }\n\n    _updateInterval() {\n      const element = this._activeElement || SelectorEngine__default['default'].findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n      if (!element) {\n        return;\n      }\n\n      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n\n      if (elementInterval) {\n        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n        this._config.interval = elementInterval;\n      } else {\n        this._config.interval = this._config.defaultInterval || this._config.interval;\n      }\n    }\n\n    _slide(directionOrOrder, element) {\n      const order = this._directionToOrder(directionOrOrder);\n\n      const activeElement = SelectorEngine__default['default'].findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n      const activeElementIndex = this._getItemIndex(activeElement);\n\n      const nextElement = element || this._getItemByOrder(order, activeElement);\n\n      const nextElementIndex = this._getItemIndex(nextElement);\n\n      const isCycling = Boolean(this._interval);\n      const isNext = order === ORDER_NEXT;\n      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n\n      const eventDirectionName = this._orderToDirection(order);\n\n      if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE)) {\n        this._isSliding = false;\n        return;\n      }\n\n      const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n      if (slideEvent.defaultPrevented) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n\n      this._isSliding = true;\n\n      if (isCycling) {\n        this.pause();\n      }\n\n      this._setActiveIndicatorElement(nextElement);\n\n      this._activeElement = nextElement;\n\n      const triggerSlidEvent = () => {\n        EventHandler__default['default'].trigger(this._element, EVENT_SLID, {\n          relatedTarget: nextElement,\n          direction: eventDirectionName,\n          from: activeElementIndex,\n          to: nextElementIndex\n        });\n      };\n\n      if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n        nextElement.classList.add(orderClassName);\n        reflow(nextElement);\n        activeElement.classList.add(directionalClassName);\n        nextElement.classList.add(directionalClassName);\n\n        const completeCallBack = () => {\n          nextElement.classList.remove(directionalClassName, orderClassName);\n          nextElement.classList.add(CLASS_NAME_ACTIVE);\n          activeElement.classList.remove(CLASS_NAME_ACTIVE, orderClassName, directionalClassName);\n          this._isSliding = false;\n          setTimeout(triggerSlidEvent, 0);\n        };\n\n        this._queueCallback(completeCallBack, activeElement, true);\n      } else {\n        activeElement.classList.remove(CLASS_NAME_ACTIVE);\n        nextElement.classList.add(CLASS_NAME_ACTIVE);\n        this._isSliding = false;\n        triggerSlidEvent();\n      }\n\n      if (isCycling) {\n        this.cycle();\n      }\n    }\n\n    _directionToOrder(direction) {\n      if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n        return direction;\n      }\n\n      if (isRTL()) {\n        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n      }\n\n      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n    }\n\n    _orderToDirection(order) {\n      if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n        return order;\n      }\n\n      if (isRTL()) {\n        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n      }\n\n      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    } // Static\n\n\n    static carouselInterface(element, config) {\n      let data = Data__default['default'].get(element, DATA_KEY);\n      let _config = { ...Default,\n        ...Manipulator__default['default'].getDataAttributes(element)\n      };\n\n      if (typeof config === 'object') {\n        _config = { ..._config,\n          ...config\n        };\n      }\n\n      const action = typeof config === 'string' ? config : _config.slide;\n\n      if (!data) {\n        data = new Carousel(element, _config);\n      }\n\n      if (typeof config === 'number') {\n        data.to(config);\n      } else if (typeof action === 'string') {\n        if (typeof data[action] === 'undefined') {\n          throw new TypeError(`No method named \"${action}\"`);\n        }\n\n        data[action]();\n      } else if (_config.interval && _config.ride) {\n        data.pause();\n        data.cycle();\n      }\n    }\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        Carousel.carouselInterface(this, config);\n      });\n    }\n\n    static dataApiClickHandler(event) {\n      const target = getElementFromSelector(this);\n\n      if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n        return;\n      }\n\n      const config = { ...Manipulator__default['default'].getDataAttributes(target),\n        ...Manipulator__default['default'].getDataAttributes(this)\n      };\n      const slideIndex = this.getAttribute('data-bs-slide-to');\n\n      if (slideIndex) {\n        config.interval = false;\n      }\n\n      Carousel.carouselInterface(target, config);\n\n      if (slideIndex) {\n        Data__default['default'].get(target, DATA_KEY).to(slideIndex);\n      }\n\n      event.preventDefault();\n    }\n\n  }\n  /**\r\n   * ------------------------------------------------------------------------\r\n   * Data Api implementation\r\n   * ------------------------------------------------------------------------\r\n   */\n\n\n  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);\n  EventHandler__default['default'].on(window, EVENT_LOAD_DATA_API, () => {\n    const carousels = SelectorEngine__default['default'].find(SELECTOR_DATA_RIDE);\n\n    for (let i = 0, len = carousels.length; i < len; i++) {\n      Carousel.carouselInterface(carousels[i], Data__default['default'].get(carousels[i], DATA_KEY));\n    }\n  });\n  /**\r\n   * ------------------------------------------------------------------------\r\n   * jQuery\r\n   * ------------------------------------------------------------------------\r\n   * add .Carousel to jQuery only if jQuery is present\r\n   */\n\n  defineJQueryPlugin(Carousel);\n  return Carousel;\n});","map":{"version":3,"sources":["../src/util/index.js","../src/carousel.js"],"names":["TRANSITION_END","toType","obj","getSelector","element","selector","hrefAttr","getElementFromSelector","document","triggerTransitionEnd","isElement","typeCheckConfig","Object","property","expectedTypes","configTypes","value","config","valueType","componentName","isVisible","elementStyle","getComputedStyle","parentNodeStyle","reflow","getjQuery","jQuery","onDOMContentLoaded","callback","isRTL","defineJQueryPlugin","plugin","$","name","JQUERY_NO_CONFLICT","NAME","DATA_KEY","EVENT_KEY","DATA_API_KEY","ARROW_LEFT_KEY","ARROW_RIGHT_KEY","TOUCHEVENT_COMPAT_WAIT","SWIPE_THRESHOLD","Default","interval","keyboard","slide","pause","wrap","touch","DefaultType","ORDER_NEXT","ORDER_PREV","DIRECTION_LEFT","DIRECTION_RIGHT","EVENT_SLIDE","EVENT_SLID","EVENT_KEYDOWN","EVENT_MOUSEENTER","EVENT_MOUSELEAVE","EVENT_TOUCHSTART","EVENT_TOUCHMOVE","EVENT_TOUCHEND","EVENT_POINTERDOWN","EVENT_POINTERUP","EVENT_DRAG_START","EVENT_LOAD_DATA_API","EVENT_CLICK_DATA_API","CLASS_NAME_CAROUSEL","CLASS_NAME_ACTIVE","CLASS_NAME_SLIDE","CLASS_NAME_END","CLASS_NAME_START","CLASS_NAME_NEXT","CLASS_NAME_PREV","CLASS_NAME_POINTER_EVENT","SELECTOR_ACTIVE","SELECTOR_ACTIVE_ITEM","SELECTOR_ITEM","SELECTOR_ITEM_IMG","SELECTOR_NEXT_PREV","SELECTOR_INDICATORS","SELECTOR_INDICATOR","SELECTOR_DATA_SLIDE","SELECTOR_DATA_RIDE","POINTER_TYPE_TOUCH","POINTER_TYPE_PEN","BaseComponent","constructor","SelectorEngine","navigator","Boolean","window","next","nextWhenVisible","prev","clearInterval","cycle","setInterval","to","activeIndex","index","EventHandler","order","_getConfig","_handleSwipe","absDeltax","Math","direction","_addEventListeners","event","_addTouchEventListeners","start","move","end","clearTimeout","setTimeout","itemImg","e","_keydown","_getItemIndex","_getItemByOrder","isNext","isPrev","lastItemIndex","isGoingToWrap","delta","itemIndex","_triggerSlideEvent","targetIndex","fromIndex","from","_setActiveIndicatorElement","activeIndicator","indicators","i","Number","_updateInterval","elementInterval","_slide","activeElement","activeElementIndex","nextElement","nextElementIndex","isCycling","directionalClassName","orderClassName","eventDirectionName","slideEvent","triggerSlidEvent","relatedTarget","completeCallBack","_directionToOrder","_orderToDirection","carouselInterface","data","Data","_config","Manipulator","action","jQueryInterface","Carousel","dataApiClickHandler","target","slideIndex","carousels","len"],"mappings":"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","sourcesContent":["import SelectorEngine from '../dom/selector-engine'\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/index.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst MAX_UID = 1000000\nconst MILLISECONDS_MULTIPLIER = 1000\nconst TRANSITION_END = 'transitionend'\n\n// Shoutout AngusCroll (https://goo.gl/pxwQGp)\nconst toType = obj => {\n  if (obj === null || obj === undefined) {\n    return `${obj}`\n  }\n\n  return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase()\n}\n\n/**\n * --------------------------------------------------------------------------\n * Public Util Api\n * --------------------------------------------------------------------------\n */\n\nconst getUID = prefix => {\n  do {\n    prefix += Math.floor(Math.random() * MAX_UID)\n  } while (document.getElementById(prefix))\n\n  return prefix\n}\n\nconst getSelector = element => {\n  let selector = element.getAttribute('data-bs-target')\n\n  if (!selector || selector === '#') {\n    let hrefAttr = element.getAttribute('href')\n\n    // The only valid content that could double as a selector are IDs or classes,\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n    // `document.querySelector` will rightfully complain it is invalid.\n    // See https://github.com/twbs/bootstrap/issues/32273\n    if (!hrefAttr || (!hrefAttr.includes('#') && !hrefAttr.startsWith('.'))) {\n      return null\n    }\n\n    // Just in case some CMS puts out a full URL with the anchor appended\n    if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\n      hrefAttr = `#${hrefAttr.split('#')[1]}`\n    }\n\n    selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null\n  }\n\n  return selector\n}\n\nconst getSelectorFromElement = element => {\n  const selector = getSelector(element)\n\n  if (selector) {\n    return document.querySelector(selector) ? selector : null\n  }\n\n  return null\n}\n\nconst getElementFromSelector = element => {\n  const selector = getSelector(element)\n\n  return selector ? document.querySelector(selector) : null\n}\n\nconst getTransitionDurationFromElement = element => {\n  if (!element) {\n    return 0\n  }\n\n  // Get transition-duration of the element\n  let { transitionDuration, transitionDelay } = window.getComputedStyle(element)\n\n  const floatTransitionDuration = Number.parseFloat(transitionDuration)\n  const floatTransitionDelay = Number.parseFloat(transitionDelay)\n\n  // Return 0 if element or transition duration is not found\n  if (!floatTransitionDuration && !floatTransitionDelay) {\n    return 0\n  }\n\n  // If multiple durations are defined, take the first\n  transitionDuration = transitionDuration.split(',')[0]\n  transitionDelay = transitionDelay.split(',')[0]\n\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER\n}\n\nconst triggerTransitionEnd = element => {\n  element.dispatchEvent(new Event(TRANSITION_END))\n}\n\nconst isElement = obj => {\n  if (!obj || typeof obj !== 'object') {\n    return false\n  }\n\n  if (typeof obj.jquery !== 'undefined') {\n    obj = obj[0]\n  }\n\n  return typeof obj.nodeType !== 'undefined'\n}\n\nconst getElement = obj => {\n  if (isElement(obj)) { // it's a jQuery object or a node element\n    return obj.jquery ? obj[0] : obj\n  }\n\n  if (typeof obj === 'string' && obj.length > 0) {\n    return SelectorEngine.findOne(obj)\n  }\n\n  return null\n}\n\nconst emulateTransitionEnd = (element, duration) => {\n  let called = false\n  const durationPadding = 5\n  const emulatedDuration = duration + durationPadding\n\n  function listener() {\n    called = true\n    element.removeEventListener(TRANSITION_END, listener)\n  }\n\n  element.addEventListener(TRANSITION_END, listener)\n  setTimeout(() => {\n    if (!called) {\n      triggerTransitionEnd(element)\n    }\n  }, emulatedDuration)\n}\n\nconst typeCheckConfig = (componentName, config, configTypes) => {\n  Object.keys(configTypes).forEach(property => {\n    const expectedTypes = configTypes[property]\n    const value = config[property]\n    const valueType = value && isElement(value) ? 'element' : toType(value)\n\n    if (!new RegExp(expectedTypes).test(valueType)) {\n      throw new TypeError(\n        `${componentName.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`\n      )\n    }\n  })\n}\n\nconst isVisible = element => {\n  if (!element) {\n    return false\n  }\n\n  if (element.style && element.parentNode && element.parentNode.style) {\n    const elementStyle = getComputedStyle(element)\n    const parentNodeStyle = getComputedStyle(element.parentNode)\n\n    return elementStyle.display !== 'none' &&\n      parentNodeStyle.display !== 'none' &&\n      elementStyle.visibility !== 'hidden'\n  }\n\n  return false\n}\n\nconst isDisabled = element => {\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n    return true\n  }\n\n  if (element.classList.contains('disabled')) {\n    return true\n  }\n\n  if (typeof element.disabled !== 'undefined') {\n    return element.disabled\n  }\n\n  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false'\n}\n\nconst findShadowRoot = element => {\n  if (!document.documentElement.attachShadow) {\n    return null\n  }\n\n  // Can find the shadow root otherwise it'll return the document\n  if (typeof element.getRootNode === 'function') {\n    const root = element.getRootNode()\n    return root instanceof ShadowRoot ? root : null\n  }\n\n  if (element instanceof ShadowRoot) {\n    return element\n  }\n\n  // when we don't find a shadow root\n  if (!element.parentNode) {\n    return null\n  }\n\n  return findShadowRoot(element.parentNode)\n}\n\nconst noop = () => {}\n\nconst reflow = element => element.offsetHeight\n\nconst getjQuery = () => {\n  const { jQuery } = window\n\n  if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n    return jQuery\n  }\n\n  return null\n}\n\nconst onDOMContentLoaded = callback => {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', callback)\n  } else {\n    callback()\n  }\n}\n\nconst isRTL = () => document.documentElement.dir === 'rtl'\n\nconst defineJQueryPlugin = plugin => {\n  onDOMContentLoaded(() => {\n    const $ = getjQuery()\n    /* istanbul ignore if */\n    if ($) {\n      const name = plugin.NAME\n      const JQUERY_NO_CONFLICT = $.fn[name]\n      $.fn[name] = plugin.jQueryInterface\n      $.fn[name].Constructor = plugin\n      $.fn[name].noConflict = () => {\n        $.fn[name] = JQUERY_NO_CONFLICT\n        return plugin.jQueryInterface\n      }\n    }\n  })\n}\n\nconst execute = callback => {\n  if (typeof callback === 'function') {\n    callback()\n  }\n}\n\nexport {\n  getElement,\n  getUID,\n  getSelectorFromElement,\n  getElementFromSelector,\n  getTransitionDurationFromElement,\n  triggerTransitionEnd,\n  isElement,\n  emulateTransitionEnd,\n  typeCheckConfig,\n  isVisible,\n  isDisabled,\n  findShadowRoot,\n  noop,\n  reflow,\n  getjQuery,\n  onDOMContentLoaded,\n  isRTL,\n  defineJQueryPlugin,\n  execute\n}\n","/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport {\n  defineJQueryPlugin,\n  getElementFromSelector,\n  isRTL,\n  isVisible,\n  reflow,\n  triggerTransitionEnd,\n  typeCheckConfig\n} from './util/index'\nimport Data from './dom/data'\nimport EventHandler from './dom/event-handler'\nimport Manipulator from './dom/manipulator'\nimport SelectorEngine from './dom/selector-engine'\nimport BaseComponent from './base-component'\n\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'carousel'\nconst DATA_KEY = 'bs.carousel'\nconst EVENT_KEY = `.${DATA_KEY}`\nconst DATA_API_KEY = '.data-api'\n\nconst ARROW_LEFT_KEY = 'ArrowLeft'\nconst ARROW_RIGHT_KEY = 'ArrowRight'\nconst TOUCHEVENT_COMPAT_WAIT = 500 // Time for mouse compat events to fire after touch\nconst SWIPE_THRESHOLD = 40\n\nconst Default = {\n  interval: 5000,\n  keyboard: true,\n  slide: false,\n  pause: 'hover',\n  wrap: true,\n  touch: true\n}\n\nconst DefaultType = {\n  interval: '(number|boolean)',\n  keyboard: 'boolean',\n  slide: '(boolean|string)',\n  pause: '(string|boolean)',\n  wrap: 'boolean',\n  touch: 'boolean'\n}\n\nconst ORDER_NEXT = 'next'\nconst ORDER_PREV = 'prev'\nconst DIRECTION_LEFT = 'left'\nconst DIRECTION_RIGHT = 'right'\n\nconst EVENT_SLIDE = `slide${EVENT_KEY}`\nconst EVENT_SLID = `slid${EVENT_KEY}`\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY}`\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY}`\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY}`\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY}`\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY}`\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY}`\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY}`\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY}`\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY}`\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`\n\nconst CLASS_NAME_CAROUSEL = 'carousel'\nconst CLASS_NAME_ACTIVE = 'active'\nconst CLASS_NAME_SLIDE = 'slide'\nconst CLASS_NAME_END = 'carousel-item-end'\nconst CLASS_NAME_START = 'carousel-item-start'\nconst CLASS_NAME_NEXT = 'carousel-item-next'\nconst CLASS_NAME_PREV = 'carousel-item-prev'\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event'\n\nconst SELECTOR_ACTIVE = '.active'\nconst SELECTOR_ACTIVE_ITEM = '.active.carousel-item'\nconst SELECTOR_ITEM = '.carousel-item'\nconst SELECTOR_ITEM_IMG = '.carousel-item img'\nconst SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev'\nconst SELECTOR_INDICATORS = '.carousel-indicators'\nconst SELECTOR_INDICATOR = '[data-bs-target]'\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]'\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]'\n\nconst POINTER_TYPE_TOUCH = 'touch'\nconst POINTER_TYPE_PEN = 'pen'\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element)\n\n    this._items = null\n    this._interval = null\n    this._activeElement = null\n    this._isPaused = false\n    this._isSliding = false\n    this.touchTimeout = null\n    this.touchStartX = 0\n    this.touchDeltaX = 0\n\n    this._config = this._getConfig(config)\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element)\n    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0\n    this._pointerEvent = Boolean(window.PointerEvent)\n\n    this._addEventListeners()\n  }\n\n  // Getters\n\n  static get Default() {\n    return Default\n  }\n\n  static get NAME() {\n    return NAME\n  }\n\n  // Public\n\n  next() {\n    if (!this._isSliding) {\n      this._slide(ORDER_NEXT)\n    }\n  }\n\n  nextWhenVisible() {\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next()\n    }\n  }\n\n  prev() {\n    if (!this._isSliding) {\n      this._slide(ORDER_PREV)\n    }\n  }\n\n  pause(event) {\n    if (!event) {\n      this._isPaused = true\n    }\n\n    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\n      triggerTransitionEnd(this._element)\n      this.cycle(true)\n    }\n\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  cycle(event) {\n    if (!event) {\n      this._isPaused = false\n    }\n\n    if (this._interval) {\n      clearInterval(this._interval)\n      this._interval = null\n    }\n\n    if (this._config && this._config.interval && !this._isPaused) {\n      this._updateInterval()\n\n      this._interval = setInterval(\n        (document.visibilityState ? this.nextWhenVisible : this.next).bind(this),\n        this._config.interval\n      )\n    }\n  }\n\n  to(index) {\n    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)\n    const activeIndex = this._getItemIndex(this._activeElement)\n\n    if (index > this._items.length - 1 || index < 0) {\n      return\n    }\n\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index))\n      return\n    }\n\n    if (activeIndex === index) {\n      this.pause()\n      this.cycle()\n      return\n    }\n\n    const order = index > activeIndex ?\n      ORDER_NEXT :\n      ORDER_PREV\n\n    this._slide(order, this._items[index])\n  }\n\n  // Private\n\n  _getConfig(config) {\n    config = {\n      ...Default,\n      ...config\n    }\n    typeCheckConfig(NAME, config, DefaultType)\n    return config\n  }\n\n  _handleSwipe() {\n    const absDeltax = Math.abs(this.touchDeltaX)\n\n    if (absDeltax <= SWIPE_THRESHOLD) {\n      return\n    }\n\n    const direction = absDeltax / this.touchDeltaX\n\n    this.touchDeltaX = 0\n\n    if (!direction) {\n      return\n    }\n\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT)\n  }\n\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event))\n    }\n\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event))\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event))\n    }\n\n    if (this._config.touch && this._touchSupported) {\n      this._addTouchEventListeners()\n    }\n  }\n\n  _addTouchEventListeners() {\n    const start = event => {\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n        this.touchStartX = event.clientX\n      } else if (!this._pointerEvent) {\n        this.touchStartX = event.touches[0].clientX\n      }\n    }\n\n    const move = event => {\n      // ensure swiping with one touch and not pinching\n      this.touchDeltaX = event.touches && event.touches.length > 1 ?\n        0 :\n        event.touches[0].clientX - this.touchStartX\n    }\n\n    const end = event => {\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n        this.touchDeltaX = event.clientX - this.touchStartX\n      }\n\n      this._handleSwipe()\n      if (this._config.pause === 'hover') {\n        // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n\n        this.pause()\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout)\n        }\n\n        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval)\n      }\n    }\n\n    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\n      EventHandler.on(itemImg, EVENT_DRAG_START, e => e.preventDefault())\n    })\n\n    if (this._pointerEvent) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event))\n      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event))\n\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT)\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event))\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event))\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event))\n    }\n  }\n\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return\n    }\n\n    if (event.key === ARROW_LEFT_KEY) {\n      event.preventDefault()\n      this._slide(DIRECTION_RIGHT)\n    } else if (event.key === ARROW_RIGHT_KEY) {\n      event.preventDefault()\n      this._slide(DIRECTION_LEFT)\n    }\n  }\n\n  _getItemIndex(element) {\n    this._items = element && element.parentNode ?\n      SelectorEngine.find(SELECTOR_ITEM, element.parentNode) :\n      []\n\n    return this._items.indexOf(element)\n  }\n\n  _getItemByOrder(order, activeElement) {\n    const isNext = order === ORDER_NEXT\n    const isPrev = order === ORDER_PREV\n    const activeIndex = this._getItemIndex(activeElement)\n    const lastItemIndex = this._items.length - 1\n    const isGoingToWrap = (isPrev && activeIndex === 0) || (isNext && activeIndex === lastItemIndex)\n\n    if (isGoingToWrap && !this._config.wrap) {\n      return activeElement\n    }\n\n    const delta = isPrev ? -1 : 1\n    const itemIndex = (activeIndex + delta) % this._items.length\n\n    return itemIndex === -1 ?\n      this._items[this._items.length - 1] :\n      this._items[itemIndex]\n  }\n\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\n    const targetIndex = this._getItemIndex(relatedTarget)\n    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element))\n\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\n      relatedTarget,\n      direction: eventDirectionName,\n      from: fromIndex,\n      to: targetIndex\n    })\n  }\n\n  _setActiveIndicatorElement(element) {\n    if (this._indicatorsElement) {\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement)\n\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE)\n      activeIndicator.removeAttribute('aria-current')\n\n      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement)\n\n      for (let i = 0; i < indicators.length; i++) {\n        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n          indicators[i].classList.add(CLASS_NAME_ACTIVE)\n          indicators[i].setAttribute('aria-current', 'true')\n          break\n        }\n      }\n    }\n  }\n\n  _updateInterval() {\n    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)\n\n    if (!element) {\n      return\n    }\n\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10)\n\n    if (elementInterval) {\n      this._config.defaultInterval = this._config.defaultInterval || this._config.interval\n      this._config.interval = elementInterval\n    } else {\n      this._config.interval = this._config.defaultInterval || this._config.interval\n    }\n  }\n\n  _slide(directionOrOrder, element) {\n    const order = this._directionToOrder(directionOrOrder)\n    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)\n    const activeElementIndex = this._getItemIndex(activeElement)\n    const nextElement = element || this._getItemByOrder(order, activeElement)\n\n    const nextElementIndex = this._getItemIndex(nextElement)\n    const isCycling = Boolean(this._interval)\n\n    const isNext = order === ORDER_NEXT\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV\n    const eventDirectionName = this._orderToDirection(order)\n\n    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE)) {\n      this._isSliding = false\n      return\n    }\n\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName)\n    if (slideEvent.defaultPrevented) {\n      return\n    }\n\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      return\n    }\n\n    this._isSliding = true\n\n    if (isCycling) {\n      this.pause()\n    }\n\n    this._setActiveIndicatorElement(nextElement)\n    this._activeElement = nextElement\n\n    const triggerSlidEvent = () => {\n      EventHandler.trigger(this._element, EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      })\n    }\n\n    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n      nextElement.classList.add(orderClassName)\n\n      reflow(nextElement)\n\n      activeElement.classList.add(directionalClassName)\n      nextElement.classList.add(directionalClassName)\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName)\n        nextElement.classList.add(CLASS_NAME_ACTIVE)\n\n        activeElement.classList.remove(CLASS_NAME_ACTIVE, orderClassName, directionalClassName)\n\n        this._isSliding = false\n\n        setTimeout(triggerSlidEvent, 0)\n      }\n\n      this._queueCallback(completeCallBack, activeElement, true)\n    } else {\n      activeElement.classList.remove(CLASS_NAME_ACTIVE)\n      nextElement.classList.add(CLASS_NAME_ACTIVE)\n\n      this._isSliding = false\n      triggerSlidEvent()\n    }\n\n    if (isCycling) {\n      this.cycle()\n    }\n  }\n\n  _directionToOrder(direction) {\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n      return direction\n    }\n\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT\n    }\n\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV\n  }\n\n  _orderToDirection(order) {\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n      return order\n    }\n\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT\n    }\n\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT\n  }\n\n  // Static\n\n  static carouselInterface(element, config) {\n    let data = Data.get(element, DATA_KEY)\n    let _config = {\n      ...Default,\n      ...Manipulator.getDataAttributes(element)\n    }\n\n    if (typeof config === 'object') {\n      _config = {\n        ..._config,\n        ...config\n      }\n    }\n\n    const action = typeof config === 'string' ? config : _config.slide\n\n    if (!data) {\n      data = new Carousel(element, _config)\n    }\n\n    if (typeof config === 'number') {\n      data.to(config)\n    } else if (typeof action === 'string') {\n      if (typeof data[action] === 'undefined') {\n        throw new TypeError(`No method named \"${action}\"`)\n      }\n\n      data[action]()\n    } else if (_config.interval && _config.ride) {\n      data.pause()\n      data.cycle()\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Carousel.carouselInterface(this, config)\n    })\n  }\n\n  static dataApiClickHandler(event) {\n    const target = getElementFromSelector(this)\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return\n    }\n\n    const config = {\n      ...Manipulator.getDataAttributes(target),\n      ...Manipulator.getDataAttributes(this)\n    }\n    const slideIndex = this.getAttribute('data-bs-slide-to')\n\n    if (slideIndex) {\n      config.interval = false\n    }\n\n    Carousel.carouselInterface(target, config)\n\n    if (slideIndex) {\n      Data.get(target, DATA_KEY).to(slideIndex)\n    }\n\n    event.preventDefault()\n  }\n}\n\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler)\n\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE)\n\n  for (let i = 0, len = carousels.length; i < len; i++) {\n    Carousel.carouselInterface(carousels[i], Data.get(carousels[i], DATA_KEY))\n  }\n})\n\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Carousel to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Carousel)\n\nexport default Carousel\n"]},"metadata":{},"sourceType":"script"}